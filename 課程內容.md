# 《CrewAI × Agentic Design Patterns》完整教案強化版

> **目標**：在既有 16 週課綱上，系統性植入四大 Agentic 設計模式——**Reflection、Tool Use、Planning、Multi-Agent**——使學生不僅學會 CrewAI API，更能掌握自主式 AI 工作流的最佳實踐。

---

## 0　整體結構對映圖

| 模組                      | 週次    | 核心 CrewAI 主題               | 對應 Agentic Pattern               | 強化活動／產出                                                                            |
| ----------------------- | ----- | -------------------------- | -------------------------------- | ---------------------------------------------------------------------------------- |
| **Framework 基礎**        | 01-02 | Agent／Task、Reasoning       | **Reflection**<br>（單 Agent 自我檢視） | - 增設 *Self-Critique Loop* 練習：<br>  1️⃣ 產生初稿 → 2️⃣ `reflection_task` 評語 → 3️⃣ 修訂再輸出 |
| **Processes & Crews**   | 03-04 | Sequential & Hierarchical  | **Planning**<br>（Road-map 分解）    | - 在 manager\_agent 中實作 `plan()` 方法，自動拆解子任務並回饋進度                                    |
| **Flows（事件驅動）**         | 05-06 | Flow Decorators & State    | **Planning**（動態調度）               | - 於 `@router()` 內寫「進度-門檻」條件，學習重新排程                                                 |
| **Tools & Memory**      | 07-08 | 30+ Tools、自訂 & Async       | **Tool Use**                     | - 以 *外匯匯率* Case：<br> LLM → 呼叫 REST API → 整合結果 → 反思修正                               |
| **Knowledge & RAG**     | 09-10 | KnowledgeSource/RAG        | Reflection＋Tool Use              | - `reflection_task` 分析檢索結果品質；若不足則自動再查                                              |
| **Training & Testing**  | 11-12 | train / guardrail / replay | **Reflection**（自我評量微調）           | - 建立 *Self-Refine* pipeline：<br> LLM-output ⇢ LLM-critique ⇢ retrain               |
| **Observability & Ops** | 13    | AgentOps & 成本              | Tool Use                         | - 使用 Prometheus/Grafana 工具整合監控資料                                                   |
| **Deployment Strategy** | 14    | Runner‧CI/CD               | Planning                         | - GitHub Actions 依子任務矩陣並行部署                                                        |
| **Capstone**            | 15-16 | 團隊專案                       | **Multi-Agent**                  | - 至少 3 角色：Planner、Executor、Reviewer；成員須互評並合併輸出                                     |

---

## 1　課綱微調（週次細節）

### Week 1-2　Reflection Pattern 導入

| 課程段落      | 補充內容                                                       |
| --------- | ---------------------------------------------------------- |
| **理論**    | - 介紹 *Self-Refine* 研究<br>- 評析零-射與反思迭代之差異                   |
| **範例**    | `reflection_task = Task(description="評分 0-10 並提出改進", ...)` |
| **Lab-1** | ① 天氣摘要 → ② `reflection_task` 打分 → ③ 自改 → ④ (可選) 多次迭代至分數≥8  |

---

### Week 3-4　Planning Pattern 深耕

1. **Lecture**：

   * Work-Breakdown Structure（WBS）→ Process 類型比較
   * `planning_llm` 與 `manager_llm` 的分工
2. **程式實作**：

   ```python
   plan = manager_agent.plan("撰寫 GitHub 趨勢報告")
   # 回傳陣列：["蒐集 Repo", "統計 star", "撰寫摘要"]
   ```
3. **Lab-2**：以 Planner->Researcher->Writer Pipeline 完成報告；學生須提交 *甘特圖* 佐證自動排程邏輯。

---

### Week 5-6　Planning × Flow

* **任務**：設計「AQI 警示 Flow」
* **重點**：`@router()` 依 AQI 數值路由「通知->重試->結束」，展示動態計畫調整。

---

### Week 7-8　Tool Use Pattern

| 重點      | 實務                                                                        |
| ------- | ------------------------------------------------------------------------- |
| Tool 分類 | 查詢、計算、資料庫、IO                                                              |
| 非同步     | `async def _arun(...)`                                                    |
| Lab-4   | - 外匯 API + CodeInterpreterTool 運算趨勢<br>- 要求 **自動 fallback**：API 失效則改用網頁爬蟲 |

---

### Week 9-10　RAG × Reflection

* **驗收**：LLM‧Search Recall < 90% → 觸發反思再檢索
* **程式**：在 `Task` 加上 `guardrail=lambda out: "..." in out`，不符則重新執行工具。

---

### Week 11-12　Self-Training Pipeline

1. 收集 Lab-5 訊息 → 建立 `train_dataset.jsonl`
2. 使用 `crewai train`；驗證 loss drop ≥ 20 %。

---

### Week 13-14　Tool-Use × Planning（Ops）

* 自動生成 *成本分析報表* → Grafana Tool 視覺化
* CI/CD 依 *Planning Matrix* 併發：測試 → 架橋 → 部署

---

### Week 15-16　Multi-Agent Capstone

| 角色              | 職責                       | Pattern 關聯  |
| --------------- | ------------------------ | ----------- |
| **Planner**     | 拆解專案，維護 Road-map         | Planning    |
| **Executor(s)** | 調用外部工具或模型                | Tool Use    |
| **Reviewer**    | 反思、打分→要求重修               | Reflection  |
| **協作機制**        | `DelegateWorkTool` 傳遞上下文 | Multi-Agent |

**評分加權**：協作日誌 + PR 對話品質 30 %。

---

## 2　評量 rubrics（Pattern-Oriented）

| 指標          | 5 ★               | 3 ★    | 1 ★     |
| ----------- | ----------------- | ------ | ------- |
| Reflection  | 自評邏輯明確、≥2 輪迭代     | 一輪迭代   | 無迭代     |
| Tool Use    | ≥2 外部工具、錯誤處理完備    | 1 工具   | 僅 LLM   |
| Planning    | 動態調整、產生 WBS & 進度表 | 靜態分解   | 無計畫     |
| Multi-Agent | 明確分工＋溝通記錄         | 分工但少互動 | 單 Agent |

---

## 3　教材與資源對照

| Pattern     | 推薦閱讀／實驗                                                 |
| ----------- | ------------------------------------------------------- |
| Reflection  | “Self-Refine” 論文 + CrewAI `reflection_task`             |
| Tool Use    | Chain-of-Abstraction Reasoning white-paper + 自訂 Tool 實作 |
| Planning    | HuggingGPT & CrewAI `planning_llm` 範例                   |
| Multi-Agent | ChatDev、CrewAI Hierarchical Process 範例                  |

---

### 結語

透過在每個模組植入 **Reflection、Tool Use、Planning、Multi-Agent** 四大設計模式，本教案將 **CrewAI** 技術與業界熱門 Agentic 思維深度融合，確保學生能真正設計、部署並優化自主 AI 系統，而非僅停留在 API 操作層面。


# CrewAI 核心組件深度探討
CrewAI 作為新一代多代理 AI 框架，其強大功能建立在精心設計的核心組件之上。本文將深入解析每個組件的運作機制、交互關係，以及在實際應用中的最佳實踐。
## Agents（代理人）：智能協作的基石
### 基礎架構設計
CrewAI 中的 **Agent** 是具備專業身份和獨立思考能力的 AI 實體[1][2]。每個 Agent 都擁有明確的角色定位，如「市場研究專家」或「技術文件寫手」，這種角色化設計確保了專業性和一致性。

**核心屬性配置**：
- **role**：定義專業角色身份，決定 Agent 的思維模式和行為特徵
- **goal**：明確的目標導向，作為所有決策的指導原則  
- **backstory**：豐富的背景故事，提供專業經驗與個性特質
- **tools**：專用工具配置，擴展 Agent 的能力邊界
- **llm**：指定語言模型，支援多種 AI 服務提供商

### 進階智能特性
**推理能力**（Reasoning）[3][4]：
設定 `reasoning=True` 後，Agent 會在執行任務前進行深度思考，包括：
1. **反思階段**：分析任務需求，理解執行脈絡
2. **計劃制定**：制定詳細的執行步驟
3. **準備評估**：判斷是否具備執行條件
4. **計劃優化**：根據評估結果調整策略

**記憶系統**[5][6]：
- **Short-Term Memory**：當前執行期間的臨時記憶，使用 RAG 技術
- **Long-Term Memory**：跨會話的持久化記憶，基於 SQLite3 存儲
- **Entity Memory**：實體記憶，追蹤人物、地點、概念等關鍵資訊

**協作機制**[7][8]：
當啟用 `allow_delegation=True` 時，Agent 自動獲得兩個協作工具：
- **Delegate Work Tool**：將任務分配給具備專業能力的同事
- **Ask Question Tool**：向團隊成員詢問特定領域的專業資訊

## Tasks（任務）：精確執行的載體
### 任務結構設計
**Task** 是 CrewAI 中的基本執行單元，每個任務都包含完整的執行指令和期待結果[2]。

**核心屬性**：
- **description**：詳細的任務描述，指導執行方向
- **expected_output**：明確的輸出要求，確保結果符合預期
- **agent**：負責執行的 Agent 指派
- **context**：上下文依賴，可引用其他任務的輸出結果
- **tools**：任務專用工具集合，提供執行所需的能力

### 執行控制機制
**異步執行**：
設定 `async_execution=True` 可讓任務並行執行，大幅提升處理效率，特別適合獨立性高的研究或分析任務。

**輸出管理**：
- **output_pydantic**：使用 Pydantic 模型進行結構化輸出驗證
- **output_json**：JSON 格式的結構化輸出
- **guardrail**：自訂驗證函數，確保輸出品質符合要求
- **callback**：任務完成後的回調處理

### TaskOutput 物件
任務執行結果封裝在 **TaskOutput** 類別中[2]，提供多種格式的輸出存取：
- **raw**：原始文字輸出
- **pydantic**：結構化模型物件
- **json_dict**：JSON 字典格式
- **agent**：執行 Agent 資訊
- **summary**：自動生成的摘要

## Crews（團隊）：協調統籌的核心
### 組織架構
**Crew** 是多 Agent 協作的組織單位，類似企業部門的運作模式[9][10]。

**組成要素**：
- **agents**：團隊成員列表，每個成員都有明確分工
- **tasks**：任務分配清單，定義工作流程
- **process**：執行流程類型（Sequential/Hierarchical/Consensual）
- **verbose**：執行過程可視化控制
- **manager_llm**：層級流程中的管理者模型

### 執行模式
**多元化執行方式**[9]：
- **kickoff()**：標準同步執行
- **kickoff_async()**：異步執行模式
- **kickoff_for_each()**：批量輸入處理
- **kickoff_for_each_async()**：批量異步執行

**CrewOutput 統一輸出**[9]：
- 整合所有任務輸出結果
- 提供詳細的 token 使用統計
- 包含完整的性能指標分析

## Flows（流程控制）：精密編排的藝術
### 事件驅動架構
**Flow** 提供結構化的工作流程管理，透過事件驅動實現精確控制[11][12]。

**核心裝飾器**：
- **@start()**：流程起始點標記
- **@listen()**：事件監聽器，響應特定事件
- **@router()**：條件路由控制，實現動態流程分支
- **@persist()**：狀態持久化，確保資料不遺失

### 狀態管理機制
**雙模式狀態**[11]：
- **結構化狀態**：基於 Pydantic 模型的強型別狀態
- **非結構化狀態**：字典型態的靈活狀態
- **自動 ID**：每個狀態自動獲得 UUID 識別碼
- **狀態傳遞**：方法間無縫的數據流轉

**流程編排**：
- **or_()**：多路監聽，任一條件觸發即執行
- **and_()**：聚合監聽，所有條件滿足才執行
- **條件分支**：基於狀態的動態路由決策

## Processes（流程）：協作模式的具現
### Sequential Process（順序流程）
**特徵**[10][13][14]：
- 任務按預定順序依次執行
- 前一任務的輸出自動成為後續任務的上下文
- 適合線性依賴關係的工作流程
- 簡單直觀，易於理解和調試

**適用場景**：
- 內容創作流程（研究→寫作→編輯）
- 數據分析管道（收集→清理→分析→報告）
- 產品開發流程（需求→設計→開發→測試）

### Hierarchical Process（層級流程）
**管理機制**[10][14][15]：
- 需要指定 `manager_llm` 或 `manager_agent`
- 管理者 Agent 負責統籌規劃和任務分配
- 基於 Agent 能力進行動態任務分配
- 管理者審核輸出並驗證完成度

**優勢特點**：
- **動態分配**：根據 Agent 專長智能分配任務
- **品質控制**：管理者層級的輸出審核機制
- **結構化管理**：清晰的指揮鏈和責任分工
- **複雜任務處理**：適合需要統一協調的大型專案

## Memory（記憶系統）：智能累積的基礎
### 多層次記憶架構
CrewAI 的記憶系統提供三種層次的資訊存儲[5][16]：

**Short-Term Memory**：
- 使用 ChromaDB 搭配 RAG 技術
- 存儲當前執行期間的互動歷史
- 提供語義搜索能力，快速檢索相關資訊

**Long-Term Memory**：
- 基於 SQLite3 的持久化存儲
- 保存跨會話的寶貴洞察和學習成果
- 支援 Agent 的經驗累積和能力提升

**Entity Memory**：
- 追蹤人物、地點、概念等實體資訊
- 建立實體間的關聯關係圖譜
- 支援複雜上下文的理解和推理

### 配置與管理
**啟用方式**：
```python
crew = Crew(
    agents=[...],
    tasks=[...],
    memory=True,  # 啟用基礎記憶系統
    embedder={"provider": "openai"}  # 自訂嵌入模型
)
```

**存儲位置**[5]：
- 自動適配不同作業系統的標準路徑
- 支援 `CREWAI_STORAGE_DIR` 環境變數自訂路徑
- 使用 ChromaDB 進行向量存儲和語義搜索

## Tools（工具）：能力擴展的利器
### 豐富的內建工具庫
CrewAI 提供超過 30 種內建工具[17][18]，涵蓋各種應用場景：

**搜索工具**：
- **SerperDevTool**：開發專用的網路搜索
- **WebsiteSearchTool**：特定網站內容搜索
- **GithubSearchTool**：GitHub 代碼庫搜索
- **YoutubeVideoSearchTool**：YouTube 影片內容搜索

**文件處理工具**：
- **PDFSearchTool**：PDF 文件內容搜索
- **CSVSearchTool**：CSV 數據結構化搜索
- **JSONSearchTool**：JSON 數據處理
- **DOCXSearchTool**：Word 文件內容提取

**數據分析工具**：
- **CodeInterpreterTool**：Python 程式碼執行與分析
- **PGSearchTool**：PostgreSQL 數據庫查詢
- **DirectorySearchTool**：文件系統導航與搜索

### 自訂工具開發
**BaseTool 繼承方式**[17][19]：
```python
from crewai.tools import BaseTool
from pydantic import BaseModel, Field

class CustomTool(BaseTool):
    name: str = "自訂工具名稱"
    description: str = "工具功能描述"
    args_schema: Type[BaseModel] = InputSchema
    
    def _run(self, argument: str) -> str:
        # 核心執行邏輯
        return "工具執行結果"
```

**@tool 裝飾器方式**[17]：
```python
from crewai.tools import tool

@tool("工具名稱")
def custom_tool(input_param: str) -> str:
    """工具功能描述"""
    # 執行邏輯
    return "處理結果"
```

### 異步工具支援
CrewAI 支援異步工具開發[17]，適合處理網路請求、文件 I/O 等非阻塞操作：

```python
@tool("異步數據獲取")
async def async_data_tool(query: str) -> str:
    """異步獲取外部數據"""
    await asyncio.sleep(1)  # 模擬異步操作
    return f"數據: {query}"
```

## Knowledge（知識系統）：智慧的源泉
### 多樣化知識源
CrewAI 支援多種知識源類型[20]，為 Agent 提供領域專業知識：

**文件類型支援**：
- **StringKnowledgeSource**：文字內容知識庫
- **PDFKnowledgeSource**：PDF 文件知識抽取
- **CSVKnowledgeSource**：結構化數據知識
- **ExcelKnowledgeSource**：Excel 試算表數據
- **CrewDoclingSource**：網頁內容知識抽取

### 配置層級架構
**Crew 層級知識**[20]：
所有 Agent 共享的通用知識，如公司政策、行業規範等。

**Agent 層級知識**[20]：
特定 Agent 的專屬知識，如技術文檔、專業資料庫等。

**混合配置**：
Agent 可同時獲得共享知識和專屬知識，實現知識的分層管理。

### RAG 檢索機制
**語義搜索**[20]：
- 基於嵌入向量的相似度計算
- 支援 `results_limit` 控制返回結果數量
- 使用 `score_threshold` 進行相關性過濾
- 自動適配不同的嵌入模型提供商

## Training（訓練）與 Testing（測試）
### Agent 訓練機制
CrewAI 提供完整的 Agent 訓練功能[21][22][23]：

**訓練方式**：
- **命令行**：`crewai train -n `
- **程式化**：`crew().train()` 方法
- **人工回饋**：訓練過程中的專家指導
- **模型優化**：基於回饋資料持續改進

**訓練效果**[22]：
- 減少幻覺現象，提升輸出可靠性
- 基於自訂數據的個性化調優
- 提升特定領域的專業表現

### 測試與調試
**調試工具**[24][25]：
- **verbose 模式**：詳細的執行日誌輸出
- **step_callback**：監控 Agent 每個執行步驟
- **隔離測試**：單獨測試 Agent 和 Task 的功能
- **重播功能**：`crewai replay -t ` 重現執行過程

**性能監控**[24]：
- **usage_metrics**：詳細的 LLM 使用統計
- **token_usage**：精確的成本計算
- **執行時間**：性能瓶頸識別
- **錯誤追蹤**：完整的異常日誌記錄

## LLMs（語言模型）：智能引擎的核心
### 廣泛的模型支援
CrewAI 支援主流的 AI 服務提供商[26]：

**商業服務**：
- **OpenAI**：GPT-4、GPT-4o、o1 系列
- **Anthropic**：Claude 3.5 Sonnet、Claude 3.5 Haiku
- **Google**：Gemini 2.0、Gemini 1.5 Pro/Flash
- **Meta**：Llama 3.1、Llama 4 系列

**本地部署**：
- **Ollama**：本地模型運行環境
- **Fireworks AI**：高性能推理服務
- **Nebius AI Studio**：企業級部署方案

### 專用模型配置
**功能導向的模型配置**[26]：
- **function_calling_llm**：工具調用專用模型，可選擇成本較低的模型
- **manager_llm**：層級流程管理專用模型
- **planning_llm**：規劃功能專用模型，預設使用 gpt-4o-mini

這種分層配置允許開發者根據不同功能的需求，選擇最適合的模型，在保證性能的同時控制成本。

## 最佳實踐與應用模式
### 架構設計原則
**模組化設計**：
- 將複雜任務分解為可管理的模組
- 每個 Agent 專注於特定領域的專業能力
- 使用 Tool 擴展 Agent 的功能邊界

**錯誤處理機制**：
- 實現完善的異常處理和恢復機制
- 使用 guardrail 函數確保輸出品質
- 設定適當的重試次數和超時限制

**性能優化策略**：
- 合理使用異步執行提升並行處理能力
- 配置緩存機制避免重複計算
- 選擇適當的語言模型平衡性能與成本

### 生產環境部署
**監控與觀測**：
- 建立全面的性能追蹤和指標收集
- 實現即時監控和自動預警機制
- 維護詳細的執行日誌和審計軌跡

**擴展性設計**：
- 採用水平擴展架構應對高併發需求
- 實現負載平衡和故障轉移機制
- 支援動態資源調整和自動擴縮容

CrewAI 的核心組件設計體現了現代 AI 系統的先進理念，通過精心設計的架構和豐富的功能模組，為開發者提供了構建企業級 AI 自動化系統的完整解決方案。掌握這些核心組件的深層運作機理，是發揮 CrewAI 最大潛力的關鍵。

[1] https://docs.crewai.com/en/concepts/agents
[2] https://docs.crewai.com/en/concepts/tasks
[3] https://docs.crewai.com/en/concepts/reasoning
[4] https://www.linkedin.com/posts/crewai-inc_agent-reasoning-is-supported-in-crewai-and-activity-7353500218954260480-zv5n
[5] https://docs.crewai.com/concepts/memory
[6] https://developer.couchbase.com/tutorial-crewai-short-term-memory-couchbase/
[7] https://crewai.net/posts/crewai-collaboration/
[8] https://docs.crewai.com/concepts/collaboration
[9] https://docs.crewai.com/en/concepts/crews
[10] https://docs.crewai.com/concepts/processes
[11] https://docs.crewai.com/en/concepts/flows
[12] https://www.crewai.com/crewai-flows
[13] https://crewai.net/posts/crewai-processes/
[14] https://ai.plainenglish.io/mastering-crewai-chapter-4-processes-e8ad3ebbadae
[15] https://help.crewai.com/ware-are-the-key-differences-between-hierarchical-and-sequential-processes-in-crewai
[16] https://dev.to/foxgem/ai-agent-memory-a-comparative-analysis-of-langgraph-crewai-and-autogen-31dp
[17] https://docs.crewai.com/concepts/tools
[18] https://github.com/0xZee/CrewAi-Tools
[19] https://docs.crewai.com/en/learn/create-custom-tools
[20] https://docs.crewai.com/en/concepts/knowledge
[21] https://docs.crewai.com/concepts/training
[22] https://www.youtube.com/watch?v=TOM_845M6-o
[23] https://www.crewai.com/webinar/building-production-agents-with-training-and-evaluation
[24] https://wandb.ai/byyoung3/crewai_debug_agent/reports/Debugging-CrewAI-multi-agent-applications--VmlldzoxMzQyNTY5NQ
[25] https://dev.to/apappascs/debugging-your-crew-isolating-agents-and-tasks-in-crewai-185k
[26] https://docs.crewai.com/en/concepts/llms
[27] https://arxiv.org/abs/2404.01347
[28] http://science.spb.ru/files/IzvestiyaTI/2024/70/01.pdf
[29] https://ieeexplore.ieee.org/document/10173738/
[30] https://ieeexplore.ieee.org/document/10521840/
[31] https://xlink.rsc.org/?DOI=D1TA09010K
[32] http://biorxiv.org/lookup/doi/10.1101/2022.07.08.499161
[33] https://link.springer.com/10.1007/s00170-023-11750-1
[34] https://link.springer.com/10.1007/s10915-023-02297-0
[35] https://dl.acm.org/doi/10.1145/2911996.2912041
[36] https://www.jstage.jst.go.jp/article/transinf/E100.D/1/E100.D_2016MUP0007/_article
[37] https://arxiv.org/pdf/2311.16542.pdf
[38] https://arxiv.org/html/2408.08188v4
[39] https://arxiv.org/pdf/2109.08214.pdf
[40] https://arxiv.org/pdf/2501.16539.pdf
[41] https://arxiv.org/pdf/2405.20252.pdf
[42] http://arxiv.org/pdf/2502.07056.pdf
[43] https://arxiv.org/html/2502.14282v2
[44] http://arxiv.org/pdf/2503.02698.pdf
[45] https://arxiv.org/pdf/2412.18695.pdf
[46] https://arxiv.org/pdf/2312.15224.pdf
[47] https://www.marktechpost.com/2025/01/17/crewai-a-guide-to-agentic-ai-collaboration-and-workflow-optimization-with-code-implementation/
[48] https://activewizards.com/blog/hierarchical-ai-agents-a-guide-to-crewai-delegation
[49] https://community.crewai.com/t/choosing-between-sequential-and-hierarchical-processes-in-crewai-for-a-shopping-chatbot/5710
[50] https://www.cohorte.co/blog/the-friendly-developers-guide-to-crewai-for-support-bots-workflow-automation
[51] https://docs.crewai.com/en/learn/hierarchical-process
[52] https://docs.crewai.com
[53] https://www.ibm.com/think/topics/crew-ai
[54] https://docs.crewai.com/en/learn/sequential-process
[55] https://docs.crewai.com/concepts/agents
[56] https://arxiv.org/abs/2408.06458
[57] https://arxiv.org/abs/2410.09407
[58] https://ora.ox.ac.uk/objects/uuid:19489c19-dc5a-464a-831d-bbf887687c41
[59] https://arxiv.org/abs/2311.13577
[60] https://arxiv.org/abs/2402.01622
[61] https://arxiv.org/abs/2406.06613
[62] https://www.semanticscholar.org/paper/2fd69fa8ebbcbdf23f3ca6dff00706df5719a156
[63] https://arxiv.org/abs/2407.05291
[64] https://arxiv.org/abs/2505.09970
[65] https://arxiv.org/abs/2410.05669
[66] http://arxiv.org/pdf/2501.16689.pdf
[67] https://arxiv.org/pdf/2312.14878.pdf
[68] https://arxiv.org/pdf/2407.10718.pdf
[69] https://arxiv.org/pdf/2309.17382.pdf
[70] https://arxiv.org/pdf/2502.16111.pdf
[71] https://arxiv.org/pdf/2402.15538.pdf
[72] http://arxiv.org/pdf/2503.03459.pdf
[73] https://arxiv.org/pdf/2502.04780.pdf
[74] https://arxiv.org/pdf/2312.05230.pdf
[75] https://arxiv.org/pdf/2406.12639.pdf
[76] https://docs.ag2.ai/latest/docs/user-guide/advanced-concepts/tools/interop/crewai/
[77] https://docs.crewai.com/concepts/planning
[78] https://www.clarifai.com/blog/build-an-ai-agent-from-scratch-with-crewai-and-clarifai
[79] https://www.firecrawl.dev/blog/crewai-multi-agent-systems-tutorial
[80] https://github.com/crewAIInc/crewAI
[81] https://docs.crewai.com/en/observability/agentops
[82] https://gist.github.com/ruvnet/15c6ef556be49e173ab0ecd6d252a7b9
[83] https://docs.crewai.com/en/observability/opik